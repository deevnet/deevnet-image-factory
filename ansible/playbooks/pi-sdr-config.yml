---
# Raspberry Pi SDR Image Provisioning Playbook (OFFLINE)
#
# This playbook is intended to run against a mounted Raspberry Pi OS image,
# where the root filesystem is mounted at chroot_root (e.g., /mnt/pi-bookworm-image).
#
# It does NOT require the image to boot or have networking.
#
# Usage (from Makefile):
#   sudo ansible-playbook -i ansible/inventory/chroot.ini ansible/pi-sdr-config.yml \
#     --extra-vars "chroot_root=/mnt/pi-bookworm-image"

- name: Configure Pi SDR Image (offline)
  hosts: localhost
  connection: local
  become: true
  gather_facts: true

  vars:
    # REQUIRED: passed in from Makefile
    chroot_root: "{{ chroot_root | default(omit) }}"

    # Image identity
    image_name: "pi-sdr-bookworm"

    # Common file paths inside the image
    # boot_config_txt is set dynamically in pre_tasks (Bookworm uses /boot/firmware/config.txt)
    boot_cmdline_txt: "{{ chroot_root }}/boot/cmdline.txt"
    marker_file: "{{ chroot_root }}/etc/packer-provisioned"

    # Enable these by default for SDR/HAT work
    enable_spi: true
    enable_i2c: true
    enable_uart: true

    # If you want SSH enabled on first boot
    enable_ssh: true

  pre_tasks:
    - name: Assert chroot_root provided
      ansible.builtin.assert:
        that:
          - chroot_root is defined
          - chroot_root | length > 1
        fail_msg: >
          chroot_root must be set (e.g. --extra-vars "chroot_root=/mnt/pi-bookworm-image")

    - name: Assert we look like a mounted rootfs
      ansible.builtin.stat:
        path: "{{ chroot_root }}/etc/os-release"
      register: osrel

    - name: Fail if mounted rootfs not found
      ansible.builtin.assert:
        that:
          - osrel.stat.exists
        fail_msg: "No /etc/os-release at {{ chroot_root }} â€” is the image mounted?"

    - name: Ensure required directories exist in image
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: "0755"
      loop:
        - "{{ chroot_root }}/etc"
        - "{{ chroot_root }}/etc/systemd/system/multi-user.target.wants"
        - "{{ chroot_root }}/boot"

    # Detect Bookworm boot config location (/boot/firmware/config.txt vs /boot/config.txt)
    - name: Check for Bookworm boot config location
      ansible.builtin.stat:
        path: "{{ chroot_root }}/boot/firmware/config.txt"
      register: boot_firmware_config

    - name: Set boot config path based on OS version
      ansible.builtin.set_fact:
        boot_config_txt: >-
          {{ boot_firmware_config.stat.exists
             | ternary(chroot_root ~ '/boot/firmware/config.txt', chroot_root ~ '/boot/config.txt') }}

  tasks:
    - name: Verify Ansible is running and show host + image paths
      ansible.builtin.debug:
        msg:
          - "Host: {{ ansible_distribution }} {{ ansible_distribution_version }}"
          - "Configuring mounted image at: {{ chroot_root }}"
          - "Boot config: {{ boot_config_txt }}"

    - name: Create marker file to verify provisioning
      ansible.builtin.copy:
        dest: "{{ marker_file }}"
        content: |
          Image: {{ image_name }}
          Build Date: {{ ansible_date_time.iso8601 }}
          Ansible Version: {{ ansible_version.full }}
        mode: "0644"
        owner: root
        group: root

    # ------------------------------------------------------------
    # SSH enablement
    # ------------------------------------------------------------
    - name: Ensure SSH is enabled on first boot (Raspberry Pi OS boot flag)
      when: enable_ssh
      ansible.builtin.file:
        path: "{{ chroot_root }}/boot/ssh"
        state: touch
        mode: "0644"

    - name: Check if ssh.service unit exists in image (/lib)
      when: enable_ssh
      ansible.builtin.stat:
        path: "{{ chroot_root }}/lib/systemd/system/ssh.service"
      register: ssh_unit_lib

    - name: Check if ssh.service unit exists in image (/usr/lib)
      when: enable_ssh
      ansible.builtin.stat:
        path: "{{ chroot_root }}/usr/lib/systemd/system/ssh.service"
      register: ssh_unit_usr_lib

    - name: Enable ssh.service by creating symlink (only if unit exists)
      when:
        - enable_ssh
        - (ssh_unit_lib.stat.exists | default(false)) or (ssh_unit_usr_lib.stat.exists | default(false))
      ansible.builtin.file:
        # IMPORTANT: this is the target path AS SEEN INSIDE THE IMAGE when it boots
        src: >-
          {{ (ssh_unit_lib.stat.exists | default(false))
              | ternary('/lib/systemd/system/ssh.service', '/usr/lib/systemd/system/ssh.service') }}
        dest: "{{ chroot_root }}/etc/systemd/system/multi-user.target.wants/ssh.service"
        state: link
        force: true

    # ------------------------------------------------------------
    # Boot configuration for HAT / SDR prerequisites
    # ------------------------------------------------------------
    - name: Write complete boot config.txt
      ansible.builtin.copy:
        dest: "{{ boot_config_txt }}"
        mode: "0644"
        content: |
          # For more options and information see
          # http://rptl.io/configtxt
          # Some settings may impact device functionality. See link above for details

          dtparam=audio=off

          camera_auto_detect=0
          display_auto_detect=0
          auto_initramfs=1

          # Safer HDMI path during bring-up
          dtoverlay=vc4-fkms-v3d
          max_framebuffers=2

          arm_64bit=1
          disable_overscan=1
          arm_boost=1

          # CaribouLite requires VC I2C + AUX SPI1 (3CS)
          # Standard SPI/I2C must be disabled (conflicts with CaribouLite)
          #dtparam=spi=on
          #dtparam=i2c_arm=on
          dtparam=i2c_vc=on
          dtoverlay=spi1-3cs
          enable_uart=1

    # ------------------------------------------------------------
    # CaribouLite / SDR stack hook points
    # ------------------------------------------------------------
    - name: Create directory for image-baked assets
      ansible.builtin.file:
        path: "{{ chroot_root }}/opt/deevnet"
        state: directory
        mode: "0755"

    - name: Create README for SDR baked image
      ansible.builtin.copy:
        dest: "{{ chroot_root }}/opt/deevnet/README-sdr.txt"
        mode: "0644"
        content: |
          Pi SDR Image (Bookworm) - CaribouLite Edition
          =====================================================================================
          This image is prepared for CaribouLite SDR HAT support.
          Reference: https://www.jeffgeerling.com/blog/2025/cariboulite-sdr-hat-sdr-on-raspberry-pi

          FIRST BOOT SETUP REQUIRED:
            CaribouLite source is cloned to /opt/cariboulite but NOT installed.
            You must run the installer manually with the hardware attached:

              cd /opt/cariboulite
              ./install.sh

            After installation, enable the SoapySDR server if needed:

              sudo systemctl enable --now SoapySDRServer

          Pre-installed:
            - CaribouLite source code (cloned and patched)
            - Build dependencies (cmake, dkms, kernel headers, etc.)
            - SoapySDR tools and modules
            - SoapySDRServer service file (not enabled at boot)

          Boot Configuration (/boot/firmware/config.txt):
            - SPI enabled (dtparam=spi=on)
            - I2C enabled (dtparam=i2c_arm=on)
            - UART enabled (enable_uart=1)
            - i2c_vc and spi1-3cs are COMMENTED OUT (enable if needed for CaribouLite)

          Post-Install Verification:
            - Probe SDR: SoapySDRUtil --probe
            - Check service: systemctl status SoapySDRServer
            - Check kernel modules: lsmod | grep smi

          Expected kernel modules (after install.sh):
            - smi_stream_dev
            - bcm2835_smi

          Network SDR Access:
            The SoapySDRServer runs on port 55132 by default.
            From a remote machine with SoapySDR installed:
              SoapySDRUtil --find="driver=remote,remote=<pi-ip>"

          Build Date: {{ ansible_date_time.iso8601 }}

    # ------------------------------------------------------------
    # CaribouLite Build Dependencies (chroot package installation)
    # ------------------------------------------------------------
    - name: Verify apt is present in chroot
      ansible.builtin.stat:
        path: "{{ chroot_root }}/usr/bin/apt-get"
      register: aptget_stat

    - name: Update apt cache inside chroot
      when: aptget_stat.stat.exists
      ansible.builtin.command:
        cmd: "chroot {{ chroot_root }} /usr/bin/apt-get update"
      changed_when: true

    - name: Install CaribouLite build dependencies
      when: aptget_stat.stat.exists
      ansible.builtin.command:
        cmd: >
          chroot {{ chroot_root }} /usr/bin/apt-get install -y
          git
          curl
          ca-certificates
          build-essential
          cmake
          libsoapysdr-dev
          soapysdr-tools
          soapysdr-module-all
          raspberrypi-kernel-headers
          dkms
      changed_when: true

    # ------------------------------------------------------------
    # Create pisdr user for CaribouLite installation
    # (install.sh refuses to run as root)
    # ------------------------------------------------------------
    - name: Create pisdr user in chroot
      ansible.builtin.command:
        cmd: >
          chroot {{ chroot_root }} useradd -m -s /bin/bash
          -G sudo,audio,video,adm,dialout,plugdev,gpio,i2c,spi
          pisdr
        creates: "{{ chroot_root }}/home/pisdr"

    - name: Set pisdr user password
      ansible.builtin.shell:
        cmd: |
          chroot {{ chroot_root }} bash -c 'echo "pisdr:pisdr" | chpasswd'
      changed_when: true

    - name: Grant pisdr passwordless sudo
      ansible.builtin.copy:
        dest: "{{ chroot_root }}/etc/sudoers.d/010_pisdr-nopasswd"
        content: 'pisdr ALL=(ALL) NOPASSWD:ALL'
        mode: "0440"

    # ------------------------------------------------------------
    # CaribouLite Clone and Patching
    # ------------------------------------------------------------
    - name: Clone CaribouLite repository
      ansible.builtin.command:
        cmd: "chroot {{ chroot_root }} git clone https://github.com/cariboulabs/cariboulite.git /opt/cariboulite"
        creates: "{{ chroot_root }}/opt/cariboulite/.git"
      changed_when: true

#    - name: Apply PR #210 patch (Bookworm config.txt path compatibility)
#      ansible.builtin.shell:
#        cmd: >
#          chroot {{ chroot_root }} bash -c
#          'cd /opt/cariboulite && curl -fsSL https://patch-diff.githubusercontent.com/raw/cariboulabs/cariboulite/pull/210.patch | git apply -v'
#      changed_when: true

    - name: Apply kernel 6.4+ class_create fix (issue #176)
      ansible.builtin.replace:
        path: "{{ chroot_root }}/opt/cariboulite/driver/smi_stream_dev.c"
        regexp: 'class_create\(THIS_MODULE,\s*DEVICE_NAME\)'
        replace: 'class_create(DEVICE_NAME)'
        backup: true

    - name: Set ownership of CaribouLite directory for pisdr
      ansible.builtin.command:
        cmd: "chroot {{ chroot_root }} chown -R pisdr:pisdr /opt/cariboulite"
      changed_when: true

    # ------------------------------------------------------------
    # NOTE: CaribouLite install.sh must be run manually on first boot
    # with the hardware attached. The repo is cloned and patched above.
    # To install: cd /opt/cariboulite && ./install.sh
    # ------------------------------------------------------------

    # ------------------------------------------------------------
    # SoapySDRServer Service Setup (installed but not enabled at boot)
    # ------------------------------------------------------------
    - name: Check if SoapySDRServer.service exists (/lib path)
      ansible.builtin.stat:
        path: "{{ chroot_root }}/lib/systemd/system/SoapySDRServer.service"
      register: soapy_service_lib

    - name: Check if SoapySDRServer.service exists (/usr/lib path)
      ansible.builtin.stat:
        path: "{{ chroot_root }}/usr/lib/systemd/system/SoapySDRServer.service"
      register: soapy_service_usr

    - name: Create SoapySDRServer systemd service file (if not installed)
      when: not (soapy_service_lib.stat.exists | default(false) or soapy_service_usr.stat.exists | default(false))
      ansible.builtin.copy:
        dest: "{{ chroot_root }}/etc/systemd/system/SoapySDRServer.service"
        mode: "0644"
        content: |
          [Unit]
          Description=SoapySDR Remote Server
          After=network.target

          [Service]
          Type=simple
          ExecStart=/usr/bin/SoapySDRServer --bind
          Restart=on-failure
          RestartSec=5

          [Install]
          WantedBy=multi-user.target

    # NOTE: SoapySDRServer is installed but NOT enabled at boot.
    # To enable manually: sudo systemctl enable --now SoapySDRServer

    # ------------------------------------------------------------
    # Validation Script (for post-install verification)
    # ------------------------------------------------------------
    - name: Install CaribouLite validation script
      ansible.builtin.copy:
        dest: "{{ chroot_root }}/home/pisdr/cariboulite-validate.sh"
        mode: "0755"
        owner: "1002"  # pisdr UID
        group: "1002"  # pisdr GID
        content: |
          #!/bin/bash
          #
          # CaribouLite SDR Validation Script
          # Validates OS configuration and tests SDR hardware functionality
          #
          # Usage: cariboulite-validate.sh [--quick|--full|--rf-test]
          #   --quick   : OS checks only (kernel modules, boot config, device nodes)
          #   --full    : OS checks + SoapySDR detection + hardware self-test (default)
          #   --rf-test : Full test + RF capture and analysis
          #

          set -euo pipefail

          # Colors
          RED='\033[0;31m'
          GREEN='\033[1;32m'
          YELLOW='\033[1;33m'
          CYAN='\033[0;36m'
          NC='\033[0m'

          # Counters
          PASS_COUNT=0
          FAIL_COUNT=0
          WARN_COUNT=0

          # Test mode
          TEST_MODE="${1:---full}"

          pass() {
              echo -e "${GREEN}[PASS]${NC} $1"
              ((PASS_COUNT++))
          }

          fail() {
              echo -e "${RED}[FAIL]${NC} $1"
              ((FAIL_COUNT++))
          }

          warn() {
              echo -e "${YELLOW}[WARN]${NC} $1"
              ((WARN_COUNT++))
          }

          info() {
              echo -e "${CYAN}[INFO]${NC} $1"
          }

          header() {
              echo ""
              echo -e "${CYAN}=== $1 ===${NC}"
          }

          # ============================================================
          # OS Configuration Checks
          # ============================================================

          check_kernel_modules() {
              header "Kernel Modules"

              if lsmod | grep -q "smi_stream_dev"; then
                  pass "smi_stream_dev module loaded"
              else
                  fail "smi_stream_dev module NOT loaded"
                  info "Run: sudo modprobe smi_stream_dev"
              fi

              if lsmod | grep -q "bcm2835_smi"; then
                  pass "bcm2835_smi module loaded"
              else
                  fail "bcm2835_smi module NOT loaded"
              fi

              if lsmod | grep -q "bcm2835_smi_dev"; then
                  warn "bcm2835_smi_dev loaded (should be blacklisted)"
              else
                  pass "bcm2835_smi_dev correctly blacklisted"
              fi
          }

          check_boot_config() {
              header "Boot Configuration"

              local config_txt=""
              if [[ -f /boot/firmware/config.txt ]]; then
                  config_txt="/boot/firmware/config.txt"
              elif [[ -f /boot/config.txt ]]; then
                  config_txt="/boot/config.txt"
              else
                  fail "config.txt not found"
                  return
              fi

              info "Checking $config_txt"

              if grep -q "^dtparam=i2c_vc=on" "$config_txt"; then
                  pass "dtparam=i2c_vc=on is enabled"
              else
                  fail "dtparam=i2c_vc=on is NOT enabled (required for EEPROM)"
              fi

              if grep -q "^dtoverlay=spi1-3cs" "$config_txt"; then
                  pass "dtoverlay=spi1-3cs is enabled"
              else
                  fail "dtoverlay=spi1-3cs is NOT enabled (required for modem/FPGA)"
              fi

              if grep -q "^dtparam=spi=on" "$config_txt"; then
                  warn "dtparam=spi=on is enabled (should be commented out)"
              else
                  pass "dtparam=spi=on correctly disabled"
              fi

              if grep -q "^dtparam=i2c_arm=on" "$config_txt"; then
                  warn "dtparam=i2c_arm=on is enabled (should be commented out)"
              else
                  pass "dtparam=i2c_arm=on correctly disabled"
              fi
          }

          check_device_nodes() {
              header "Device Nodes"

              if [[ -c /dev/smi ]]; then
                  pass "/dev/smi character device exists"
                  local perms
                  perms=$(stat -c "%a" /dev/smi)
                  if [[ "$perms" == "666" ]]; then
                      pass "/dev/smi has correct permissions (666)"
                  else
                      warn "/dev/smi permissions are $perms (expected 666)"
                  fi
              else
                  fail "/dev/smi device NOT found"
              fi

              if ls /dev/spidev1.* >/dev/null 2>&1; then
                  pass "SPI1 devices present (/dev/spidev1.*)"
              else
                  warn "SPI1 devices not found"
              fi

              if [[ -c /dev/i2c-10 ]] || [[ -c /dev/i2c-0 ]]; then
                  pass "I2C device present"
              else
                  warn "I2C device not found (may be OK)"
              fi
          }

          check_modprobe_config() {
              header "Modprobe Configuration"

              if [[ -f /etc/modprobe.d/smi_stream_mod_cariboulite.conf ]]; then
                  pass "SMI stream module config exists"
              else
                  warn "SMI stream module config not found (created by install.sh)"
              fi

              if [[ -f /etc/modprobe.d/blacklist-bcm_smi.conf ]]; then
                  pass "BCM SMI blacklist config exists"
              else
                  warn "BCM SMI blacklist config not found (created by install.sh)"
              fi
          }

          # ============================================================
          # SoapySDR Tests
          # ============================================================

          check_soapysdr_find() {
              header "SoapySDR Device Detection"

              if ! command -v SoapySDRUtil &>/dev/null; then
                  fail "SoapySDRUtil not found in PATH"
                  return
              fi

              local output
              if output=$(SoapySDRUtil --find 2>&1); then
                  if echo "$output" | grep -q "driver=Cariboulite"; then
                      pass "CaribouLite device detected by SoapySDR"
                      if echo "$output" | grep -q "channel = S1G"; then
                          pass "S1G channel found (389-510 MHz, 779-1020 MHz)"
                      fi
                      if echo "$output" | grep -q "channel = HiF"; then
                          pass "HiF channel found (1-6000 MHz)"
                      fi
                  else
                      fail "CaribouLite device NOT detected"
                  fi
              else
                  fail "SoapySDRUtil --find failed"
              fi
          }

          check_soapysdr_probe() {
              header "SoapySDR Device Probe"

              if ! command -v SoapySDRUtil &>/dev/null; then
                  return
              fi

              local output
              if output=$(SoapySDRUtil --probe="driver=Cariboulite" 2>&1); then
                  if echo "$output" | grep -q "hardware=Cariboulite"; then
                      pass "SoapySDR probe successful"
                  else
                      warn "Probe returned but hardware info missing"
                  fi
              else
                  fail "SoapySDR probe failed"
              fi
          }

          # ============================================================
          # Hardware Self-Test
          # ============================================================

          run_hardware_test() {
              header "Hardware Self-Test"

              local test_app="/opt/cariboulite/build/cariboulite_test_app"

              if [[ ! -x "$test_app" ]]; then
                  warn "cariboulite_test_app not found (run install.sh first)"
                  return
              fi

              info "Running hardware self-test..."

              local output
              if output=$("$test_app" 2>&1 | head -50); then
                  if echo "$output" | grep -q "FPGA.*operational\|FPGA.*running\|FPGA.*Success"; then
                      pass "FPGA initialized successfully"
                  else
                      warn "FPGA status unclear"
                  fi

                  if echo "$output" | grep -q "AT86RF215\|Modem.*Version"; then
                      pass "AT86RF215 modem detected"
                  else
                      warn "Modem detection unclear"
                  fi

                  if echo "$output" | grep -q "RFFC507"; then
                      pass "RFFC5072 mixer detected"
                  else
                      warn "Mixer detection unclear"
                  fi

                  if echo "$output" | grep -q "Self-test.*success"; then
                      pass "Hardware self-test completed successfully"
                  fi
              else
                  fail "Hardware test application failed to run"
              fi
          }

          # ============================================================
          # RF Capture Test
          # ============================================================

          run_rf_test() {
              header "RF Capture Test"

              local capture_file="/tmp/cariboulite_test_capture.cs16"
              local freq=100000000
              local samples=500000

              if ! command -v cariboulite_util &>/dev/null; then
                  warn "cariboulite_util not found in PATH"
                  return
              fi

              info "Capturing RF samples at 100 MHz..."

              if cariboulite_util -c 1 -f $freq -g 50 -n $samples "$capture_file" 2>&1; then
                  if [[ -f "$capture_file" ]]; then
                      local file_size
                      file_size=$(stat -c%s "$capture_file")
                      if [[ $file_size -gt 0 ]]; then
                          pass "RF capture successful ($file_size bytes)"
                          local zero_check
                          zero_check=$(od -A n -t x1 "$capture_file" | head -10 | tr -d ' \n')
                          if [[ "$zero_check" =~ ^0+$ ]]; then
                              fail "Captured data is all zeros"
                          else
                              pass "Captured data contains valid samples"
                          fi
                      else
                          fail "Capture file is empty"
                      fi
                      rm -f "$capture_file"
                  else
                      fail "Capture file not created"
                  fi
              else
                  fail "RF capture command failed"
              fi
          }

          # ============================================================
          # Summary
          # ============================================================

          print_summary() {
              echo ""
              echo -e "${CYAN}============================================${NC}"
              echo -e "${CYAN}           VALIDATION SUMMARY${NC}"
              echo -e "${CYAN}============================================${NC}"
              echo ""
              echo -e "  ${GREEN}Passed:${NC}   $PASS_COUNT"
              echo -e "  ${RED}Failed:${NC}   $FAIL_COUNT"
              echo -e "  ${YELLOW}Warnings:${NC} $WARN_COUNT"
              echo ""

              if [[ $FAIL_COUNT -eq 0 ]]; then
                  echo -e "${GREEN}All critical tests passed!${NC}"
                  return 0
              else
                  echo -e "${RED}Some tests failed. Please review above.${NC}"
                  return 1
              fi
          }

          # ============================================================
          # Main
          # ============================================================

          main() {
              echo ""
              echo -e "${CYAN}CaribouLite SDR Validation${NC}"
              echo -e "${CYAN}==========================${NC}"
              echo ""
              info "Test mode: $TEST_MODE"
              info "Hostname: $(hostname)"
              info "Kernel: $(uname -r)"
              info "Date: $(date)"

              check_kernel_modules
              check_boot_config
              check_device_nodes
              check_modprobe_config

              if [[ "$TEST_MODE" == "--full" ]] || [[ "$TEST_MODE" == "--rf-test" ]]; then
                  check_soapysdr_find
                  check_soapysdr_probe
                  run_hardware_test
              fi

              if [[ "$TEST_MODE" == "--rf-test" ]]; then
                  run_rf_test
              fi

              print_summary
          }

          if [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
              echo "CaribouLite SDR Validation Script"
              echo ""
              echo "Usage: $0 [--quick|--full|--rf-test]"
              echo ""
              echo "Options:"
              echo "  --quick   OS checks only (kernel modules, boot config, devices)"
              echo "  --full    OS checks + SoapySDR + hardware self-test (default)"
              echo "  --rf-test Full test + RF capture verification"
              exit 0
          fi

          main
